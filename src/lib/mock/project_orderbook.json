{
    "title": "C++ Orderbook with Advanced Order Types",
    "difficulty": "Medium",
    "timeline": "1-2 weeks",
    "description": "This project focuses on implementing a multi-order type order book from scratch using C++. An order book is a central component in financial exchanges, responsible for matching buy and sell orders. The orderbook will support various order types, going beyond the standard Good Till Cancel orders to include Fill and Kill orders.",
    "jobs": [
      { "title": "Machine Learning Engineer — NLP (Intern/Entry)", "url": "https://example.com/jobs/ml-nlp-intern" },
      { "title": "Research Engineer — Tokenization/Preprocessing", "url": "https://example.com/jobs/research-engineer-tokenization" },
      { "title": "Data Engineer — Text Processing", "url": "https://example.com/jobs/data-engineer-text" }
    ],
    "skills": [
      "C++ fundamentals",
      "Algorithms and data structures",
      "Object-oriented programming",
      "Orderbook mechanics",
      "Pointers and memory management"
    ],
    "metadata": [
        {
            "name": "1. Core Enumerations & Type Aliases",
            "overview": "Define the strongly-typed building blocks for the order book: trade side, order type, and canonical integer aliases for price, quantity, and IDs. These headers will be included across the project and must remain minimal, dependency-light, and consistent.",
            "deliverables": [
              {
                "task": "Side.h",
                "spec": "Provide a scoped enumeration for the trade direction.",
                "implementation": [
                  "Use `enum class` (scoped) to prevent implicit conversions and name collisions (compiler enforces type safety).",
                  "Keep the header minimal: `#pragma once` and the enum declaration only—no includes required.",
                  "Name the two values clearly (`Buy`, `Sell`) to align with matching logic and tests."
                ]
              },
              {
                "task": "OrderType.h",
                "spec": "Provide a scoped enumeration for supported order behaviors used throughout matching and policy checks.",
                "implementation": [
                  "Use `enum class` to keep types explicit and avoid mixing with integers.",
                  "List all policies referenced by the engine: `GoodTillCancel`, `FillAndKill` (IOC), `FillOrKill` (FOK), `GoodForDay`, `Market`.",
                  "Keep it header-only with just `#pragma once`; no additional includes are needed."
                ]
              },
              {
                "task": "Usings.h",
                "spec": "Define fixed-width aliases used everywhere for prices, quantities, and order IDs, plus a small container of IDs.",
                "implementation": [
                  "Add `#pragma once` and include only what's necessary: `<vector>` (the repo omits `<cstdint>` and relies on transitive includes, but keeping dependencies minimal is the goal).",
                  "Create `using` aliases to encode domain semantics and portability: `Price` (`std::int32_t`), `Quantity` (`std::uint32_t`), `OrderId` (`std::uint64_t`).",
                  "Define `OrderIds` as `std::vector<OrderId>` to collect IDs for batch operations (e.g., cancellations).",
                  "Prefer fixed-width integer types for cross-platform determinism and to document size expectations."
                ]
              }
            ],
            "learning_materials": [
              "Why enum class? Scoped enums avoid accidental int conversions and reduce naming conflicts.",
              "`using` aliases encode domain semantics (Price, Quantity, OrderId) and enable easy type refactoring later.",
              "Keep foundational headers tiny and dependency-light to avoid circular includes and speed up builds.",
              "Consistent, fixed-width integer usage is important for determinism across platforms."
            ],
            "code_snippets": [
              {
                "filename": "Side.h",
                "code": "#pragma once\n\nenum class Side\n{\n    Buy,\n    Sell\n};\n"
              },
              {
                "filename": "OrderType.h",
                "code": "#pragma once\n\nenum class OrderType\n{\n\tGoodTillCancel,\n\tFillAndKill,\n\tFillOrKill,\n\tGoodForDay,\n\tMarket,\n};\n"
              },
              {
                "filename": "Usings.h",
                "code": "#pragma once\n\n#include <vector>\n\nusing Price = std::int32_t;\nusing Quantity = std::uint32_t;\nusing OrderId = std::uint64_t;\nusing OrderIds = std::vector<OrderId>;\n"
              }
            ]
        },
        {
            "name": "2. Constants",
            "overview": "Centralize sentinel values used throughout the engine (e.g., an invalid price) in a tiny header so all components share a single source of truth.",
            "deliverables": [
              {
                "task": "include/Constants.h",
                "spec": "Expose project-wide constant(s) such as an invalid price sentinel to indicate an unset or unusable value.",
                "implementation": [
                  "Create a lightweight header with `#pragma once` so it's safe to include anywhere.",
                  "Include the aliases header first (for `Price`) and then `<limits>` to access `std::numeric_limits<T>`.",
                  "Follow the repository style by defining a small holder type (e.g., a `struct Constants`) and declaring the sentinel as a `static` class data member.",
                  "Use `std::numeric_limits<Price>::quiet_NaN()` exactly as in the repository for the invalid price sentinel (note: this mirrors the repo even though NaN is only meaningful for floating-point types).",
                  "Keep dependencies minimal and avoid introducing additional includes beyond `\"Usings.h\"` and `<limits>`."
                ]
              }
            ],
            "learning_materials": [
              "Why centralize sentinels: prevents scattered magic numbers and keeps validation consistent.",
              "Header-only constants: enable broad reuse without extra translation units.",
              "Sentinel semantics: an invalid value communicates 'unset' or 'not applicable' through types rather than ad hoc checks."
            ],
            "code_snippets": [
              {
                "filename": "Constants.h",
                "code": "#pragma once\n\n#include <limits>\n\n#include \"Usings.h\"\n\nstruct Constants\n{\n    static const Price InvalidPrice = std::numeric_limits<Price>::quiet_NaN();\n};\n"
              }
            ]
        },
        {
            "name": "3. Level Types & Aggregated Views",
            "overview": "Define simple, POD-style structures to represent per-price aggregated quantities and expose a read-only snapshot of the order book's bid and ask levels. These types are used by the order book to report state for testing, monitoring, or UI display without exposing internal storage details.",
            "deliverables": [
              {
                "task": "include/LevelInfo.h",
                "spec": "A lightweight struct holding a price and the total remaining quantity at that price level, plus an alias for a collection of levels.",
                "implementation": [
                  "Use a trivial POD `struct` with plain public fields for straightforward copying, logging, and serialization.",
                  "Add `#pragma once` and include the shared aliases header (`\"Usings.h\"`) so `Price` and `Quantity` are consistent.",
                  "Create a convenience alias `using LevelInfos = std::vector<LevelInfo>;` for returning multiple levels.",
                  "Rely on standard STL containers (`std::vector`) and simple struct definitions—no methods needed here.",
                  "Prefer simple constructor-less structs to keep the snapshot type lightweight and dependency-free."
                ]
              },
              {
                "task": "include/OrderbookLevelInfos.h",
                "spec": "A small wrapper that bundles bid and ask `LevelInfos` and exposes const getters, serving as the read-only snapshot type returned by the order book.",
                "implementation": [
                  "Add `#pragma once` and include `\"LevelInfo.h\"`.",
                  "Declare a small `class` that stores two members: `LevelInfos bids_` and `LevelInfos asks_`.",
                  "Initialize both via a constructor initialization list to ensure valid state on creation.",
                  "Expose const-qualified accessor methods (`GetBids() const`, `GetAsks() const`) to preserve immutability of snapshots.",
                  "Keep the header minimal—no mutations or heavy logic; just constructor and const getters."
                ]
              }
            ],
            "learning_materials": [
              "Aggregated level views separate external reporting from internal storage (lists/maps), reducing coupling.",
              "Plain-old-data (POD) structs are easy to pass by value, serialize, and log.",
              "Returning const references from getters encourages immutable snapshot patterns."
            ],
            "code_snippets": [
              {
                "filename": "LevelInfo.h",
                "code": "#pragma once\n\n#include \"Usings.h\"\n\nstruct LevelInfo\n{\n    Price price_;\n    Quantity quantity_;\n};\n\nusing LevelInfos = std::vector<LevelInfo>;\n"
              },
              {
                "filename": "OrderbookLevelInfos.h",
                "code": "#pragma once\n\n#include \"LevelInfo.h\"\n\nclass OrderbookLevelInfos\n{\npublic:\n    OrderbookLevelInfos(const LevelInfos& bids, const LevelInfos& asks)\n        : bids_{ bids }\n        , asks_{ asks }\n    { }\n\n    const LevelInfos& GetBids() const { return bids_; }\n    const LevelInfos& GetAsks() const { return asks_; }\n\nprivate:\n    LevelInfos bids_;\n    LevelInfos asks_;\n};\n"
              }
            ]
        },
        {
            "name": "4. Trade Records",
            "overview": "Introduce lightweight types to represent executed trades. Each match produces two trade fragments—one for the bid and one for the ask—which are bundled into a single Trade object. A collection of these is returned by the matching engine to describe what executed.",
            "deliverables": [
              {
                "task": "include/TradeInfo.h",
                "spec": "A plain struct describing one side of a trade: which order participated, at what price, and for what quantity.",
                "implementation": [
                  "Create a trivial POD `struct` with three public fields: `OrderId`, `Price`, and `Quantity`. This keeps copying/logging/serialization simple.",
                  "Add `#pragma once` and include the shared aliases header (`\"Usings.h\"`) so field types are consistent across the project.",
                  "Keep the type method-free; it's a data carrier used by matching and reporting.",
                  "Use clear, semantic field names (e.g., `orderId_`, `price_`, `quantity_`) to align with trade logs."
                ]
              },
              {
                "task": "include/Trade.h",
                "spec": "A small class that bundles two TradeInfo records—bid and ask—into a single Trade object, plus a convenient alias for a vector of trades.",
                "implementation": [
                  "Add `#pragma once` and include `\"TradeInfo.h\"`.",
                  "Declare a lightweight `class` with two private members of type `TradeInfo` (bid and ask).",
                  "Provide a simple constructor that initializes both members via an initialization list.",
                  "Expose const-qualified accessors (`GetBidTrade() const`, `GetAskTrade() const`) for read-only retrieval.",
                  "Add a convenience alias `using Trades = std::vector<Trade>;` to represent batches of executions returned by the matcher.",
                  "Rely only on standard containers (`std::vector`) and straightforward class/constructor patterns to keep the header dependency-light."
                ]
              }
            ],
            "learning_materials": [
              "Trade events are inherently two-sided; modeling both sides explicitly simplifies auditing and testing.",
              "Keeping TradeInfo as a POD makes it trivial to store, log, and serialize.",
              "Returning a `std::vector<Trade>` allows the matcher to report sweeps (multiple fills from a single incoming order)."
            ],
            "code_snippets": [
              {
                "filename": "TradeInfo.h",
                "code": "#pragma once\n\n#include \"Usings.h\"\n\nstruct TradeInfo\n{\n    OrderId orderId_;\n    Price price_;\n    Quantity quantity_;\n};\n"
              },
              {
                "filename": "Trade.h",
                "code": "#pragma once\n\n#include \"TradeInfo.h\"\n\nclass Trade\n{\npublic:\n    Trade(const TradeInfo& bidTrade, const TradeInfo& askTrade)\n        : bidTrade_{ bidTrade }\n        , askTrade_{ askTrade }\n    { }\n\n    const TradeInfo& GetBidTrade() const { return bidTrade_; }\n    const TradeInfo& GetAskTrade() const { return askTrade_; }\n\nprivate:\n    TradeInfo bidTrade_;\n    TradeInfo askTrade_;\n};\n\nusing Trades = std::vector<Trade>;\n"
              }
            ]
        },
        {
            "name": "5. The Order Object",
            "overview": "Implement the core Order type that models a single instruction on the book. It owns immutable identity (order id, side, type, price at creation) and mutable state (remaining quantity). It provides safe fill semantics, derived status accessors, and a helper to convert Market orders into GoodTillCancel limits at runtime.",
            "deliverables": [
              {
                "task": "include/Order.h",
                "spec": "Declare the Order class header and expose storage aliases used by the book (shared_ptr + list).",
                "implementation": [
                  "Add header guard via `#pragma once`.",
                  "Include enums (\"OrderType.h\", \"Side.h\"), aliases (\"Usings.h\"), constants (\"Constants.h\"), and standard utilities (`<list>`, `<exception>`, `<format>`).",
                  "Keep the header dependency-light and focused on declarations (no non-trivial inline algorithms beyond simple guards)."
                ]
              },
              {
                "task": "Constructors",
                "spec": "Provide a full constructor for any order type and a convenience constructor for Market orders.",
                "implementation": [
                  "Full ctor: `Order(OrderType orderType, OrderId orderId, Side side, Price price, Quantity quantity)` initializes all fields and sets `remainingQuantity_ = quantity`.",
                  "Market convenience ctor: `Order(OrderId orderId, Side side, Quantity quantity)` delegates to the full ctor with `OrderType::Market` and `Constants::InvalidPrice`."
                ]
              },
              {
                "task": "Accessors",
                "spec": "Expose const-qualified getters and derived state helpers.",
                "implementation": [
                  "Provide: `GetOrderId()`, `GetSide()`, `GetPrice()`, `GetOrderType()`, `GetInitialQuantity()`, `GetRemainingQuantity()`.",
                  "Derived helpers: `GetFilledQuantity()` returns `initial - remaining`; `IsFilled()` returns `remaining == 0`.",
                  "All accessors must be `const` and trivial (no side effects)."
                ]
              },
              {
                "task": "Mutators & Helpers",
                "spec": "Implement safe state changes and policy-bound transformations.",
                "implementation": [
                  "`Fill(Quantity quantity)`: bounds-check against `GetRemainingQuantity()`; on overflow, throw `std::logic_error` with a clear `std::format` message; otherwise decrement remaining.",
                  "`ToGoodTillCancel(Price price)`: only valid when `GetOrderType() == OrderType::Market`; otherwise throw `std::logic_error`. On success, set `price_ = price` and `orderType_ = OrderType::GoodTillCancel`."
                ]
              },
              {
                "task": "Aliases",
                "spec": "Publish storage aliases used throughout the order book.",
                "implementation": [
                  "Define at the end of the header: `using OrderPointer = std::shared_ptr<Order>;`",
                  "`using OrderPointers = std::list<OrderPointer>;`"
                ]
              },
              {
                "task": "Includes",
                "spec": "List and justify required includes for this header.",
                "implementation": [
                  "Standard: `<list>` (for OrderPointers), `<exception>` (for `std::logic_error`), `<format>` (for formatted error messages).",
                  "Project: `\"OrderType.h\"`, `\"Side.h\"`, `\"Usings.h\"`, `\"Constants.h\"`."
                ]
              }
            ],
            "learning_materials": [
              "Price–time priority requires stable iterators at each price level; std::list preserves iterator validity as orders append.",
              "Derived state (filled = initial - remaining) avoids consistency bugs versus storing a separate filled field.",
              "Market orders start unpriced; converting them to GTC at the worst opposing price routes all matching through one path.",
              "Defensive programming: validate mutations (e.g., Fill) and signal misuse via exceptions with clear diagnostics."
            ],
            "code_snippets": [
              {
                "filename": "Order.h",
                "code": "#pragma once\n\n#include <list>\n#include <exception>\n#include <format>\n\n#include \"OrderType.h\"\n#include \"Side.h\"\n#include \"Usings.h\"\n#include \"Constants.h\"\n\n\nclass Order\n{\npublic:\n    Order(OrderType orderType, OrderId orderId, Side side, Price price, Quantity quantity)\n        : orderType_{ orderType }\n        , orderId_{ orderId }\n        , side_{ side }\n        , price_{ price }\n        , initialQuantity_{ quantity }\n        , remainingQuantity_{ quantity }\n    { }\n\n    Order(OrderId orderId, Side side, Quantity quantity)\n        : Order(OrderType::Market, orderId, side, Constants::InvalidPrice, quantity)\n    { }\n\n    OrderId GetOrderId() const { return orderId_; }\n    Side GetSide() const { return side_; }\n    Price GetPrice() const { return price_; }\n    OrderType GetOrderType() const { return orderType_; }\n    Quantity GetInitialQuantity() const { return initialQuantity_; }\n    Quantity GetRemainingQuantity() const { return remainingQuantity_; }\n    Quantity GetFilledQuantity() const { return GetInitialQuantity() - GetRemainingQuantity(); }\n    bool IsFilled() const { return GetRemainingQuantity() == 0; }\n    void Fill(Quantity quantity)\n    {\n        if (quantity > GetRemainingQuantity())\n            throw std::logic_error(std::format(\"Order ({}) cannot be filled for more than its remaining quantity.\", GetOrderId()));\n\n        remainingQuantity_ -= quantity;\n    }\n    void ToGoodTillCancel(Price price) \n    { \n        if (GetOrderType() != OrderType::Market)\n            throw std::logic_error(std::format(\"Order ({}) cannot have its price adjusted, only market orders can.\", GetOrderId()));\n\n        price_ = price;\n        orderType_ = OrderType::GoodTillCancel;\n    }\n\nprivate:\n    OrderType orderType_;\n    OrderId orderId_;\n    Side side_;\n    Price price_;\n    Quantity initialQuantity_;\n    Quantity remainingQuantity_;\n};\n\nusing OrderPointer = std::shared_ptr<Order>;\nusing OrderPointers = std::list<OrderPointer>;\n"
              }
            ]
        },
        {
            "name": "6. Order Modification",
            "overview": "Provide a lightweight value type to represent cancel-and-replace semantics. This object carries the new desired fields (price, side, quantity) for an existing order ID and can materialize a fresh Order instance while preserving the original order type.",
            "deliverables": [
              {
                "task": "include/OrderModify.h",
                "spec": "Declare a small class that stores OrderId, Side, Price, and Quantity, exposes trivial getters, and provides a factory method to create a new Order from these fields while accepting an explicit OrderType.",
                "implementation": [
                  "Add `#pragma once` and include only what you use: `\"Order.h\"` (needed for `Order`, `OrderPointer`, and `std::make_shared`).",
                  "Store four private members: `OrderId orderId_; Price price_; Side side_; Quantity quantity_;`.",
                  "Provide a simple constructor that initializes all four members via an initialization list.",
                  "Expose const-qualified getters: `GetOrderId()`, `GetPrice()`, `GetSide()`, `GetQuantity()` — keep them trivial (no side effects).",
                  "Implement `OrderPointer ToOrderPointer(OrderType type) const` using `std::make_shared<Order>(type, GetOrderId(), GetSide(), GetPrice(), GetQuantity());`.",
                  "Keep the header dependency-light: no extra includes beyond `\"Order.h\"`; avoid adding logic unrelated to describing a modification intent.",
                  "Tip: Treat this as a pure value object — no mutation methods — so cancel-and-replace flows remain simple to reason about."
                ]
              }
            ],
            "learning_materials": [
              "Cancel-and-replace flows: most matching engines implement modification as a logical cancel of the old order followed by the addition of a new order.",
              "Immutability at the edge: keeping OrderModify as a simple value object avoids partial updates and makes the API easy to reason about.",
              "Separation of concerns: OrderModify describes intent; Orderbook owns the actual cancel and re-add logic."
            ],
            "code_snippets": [
              {
                "filename": "OrderModify.h",
                "code": "#pragma once\n\n#include \"Order.h\"\n\nclass OrderModify\n{\npublic:\n    OrderModify(OrderId orderId, Side side, Price price, Quantity quantity)\n        : orderId_{ orderId }\n        , price_{ price }\n        , side_{ side }\n        , quantity_{ quantity }\n    { }\n\n    OrderId GetOrderId() const { return orderId_; }\n    Price GetPrice() const { return price_; }\n    Side GetSide() const { return side_; }\n    Quantity GetQuantity() const { return quantity_; }\n\n    OrderPointer ToOrderPointer(OrderType type) const\n    {\n        return std::make_shared<Order>(type, GetOrderId(), GetSide(), GetPrice(), GetQuantity());\n    }\n\nprivate:\n    OrderId orderId_;\n    Price price_;\n    Side side_;\n    Quantity quantity_;\n};\n"
              }
            ]
        },
        {
            "name": "7. Orderbook: Internal Storage & Private APIs",
            "overview": "Define the in-memory structure of the matching engine and its private helpers. This header declares price ladders for bids/asks, an O(1) order index for fast cancels/modifies, per-price level metadata for bookkeeping and FOK checks, and internal methods for matching and maintenance.",
            "deliverables": [
              {
                "task": "include/Orderbook.h",
                "spec": "Declare the Orderbook class with all internal data structures and private APIs required by the engine. Include nested helper structs for order location and per-level aggregates, ordered maps for price ladders, an ID index, and concurrency members for the GFD pruning thread.",
                "implementation": [
                  "Price ladders: use two ordered maps—`std::map<Price, OrderPointers, std::greater<Price>>` for bids (best first) and `std::map<Price, OrderPointers, std::less<Price>>` for asks (best first). Each value is a `std::list<OrderPointer>` to preserve FIFO and iterator stability.",
                  "O(1) ID index: maintain `std::unordered_map<OrderId, OrderEntry>` where `OrderEntry` holds `{ OrderPointer, OrderPointers::iterator }` so cancels/fills can erase in O(1) using the saved iterator.",
                  "Per-level metadata: add `struct LevelData { Quantity quantity_; Quantity count_; enum class Action { Add, Remove, Match }; }` and store it in `std::unordered_map<Price, LevelData> data_` to support quick FOK feasibility and housekeeping.",
                  "Private helpers: declare `CanMatch(Side, Price) const`, `CanFullyFill(Side, Price, Quantity) const`, `Trades MatchOrders()`, and the event hooks `OnOrderAdded`, `OnOrderCancelled`, `OnOrderMatched`, plus `UpdateLevelData(Price, Quantity, LevelData::Action)` to centralize aggregate updates.",
                  "Cancellation utilities: include `CancelOrders(OrderIds)` and `CancelOrderInternal(OrderId)` for internal removals without re-checking invariants.",
                  "GFD maintenance: declare `void PruneGoodForDayOrders();` and add thread members to run it in the background: `std::thread ordersPruneThread_; std::condition_variable shutdownConditionVariable_; std::atomic<bool> shutdown_{false};`",
                  "Thread safety: protect all shared state with `mutable std::mutex ordersMutex_`. Public mutators will lock this; internal helpers assume the caller holds the lock.",
                  "Special member functions: disable copying/moving to avoid accidental sharing of internal state (delete copy/move ctor/assignment).",
                  "Includes: add `<map>`, `<unordered_map>`, `<thread>`, `<condition_variable>`, `<mutex>`, and project headers `\"Usings.h\"`, `\"Order.h\"`, `\"OrderModify.h\"`, `\"OrderbookLevelInfos.h\"`, `\"Trade.h\"`.",
                  "Rationale: ordered maps give deterministic top-of-book selection; lists provide stable iterators for price–time priority; the ID index avoids linear scans; centralized level updates keep invariants consistent."
                ]
              }
            ],
            "learning_materials": [
              "Price-time priority: ordered maps (bids desc, asks asc) plus per-price FIFO queues preserve market semantics.",
              "OrderEntry (pointer + iterator) enables O(1) cancels/modifies without scanning a price level.",
              "LevelData aggregates ({quantity, count}) allow fast feasibility checks (e.g., FOK) and consistent housekeeping.",
              "Background services (e.g., GFD pruning) require clear ownership and shutdown protocols to avoid races or leaks."
            ],
            "code_snippets": [
              {
                "filename": "Orderbook.h",
                "code": "#pragma once\n\n#include <map>\n#include <unordered_map>\n#include <thread>\n#include <condition_variable>\n#include <mutex>\n\n#include \"Usings.h\"\n#include \"Order.h\"\n#include \"OrderModify.h\"\n#include \"OrderbookLevelInfos.h\"\n#include \"Trade.h\"\n\nclass Orderbook\n{\nprivate:\n\n    struct OrderEntry\n    {\n        OrderPointer order_{ nullptr };\n        OrderPointers::iterator location_;\n    };\n\n    struct LevelData\n    {\n        Quantity quantity_{ };\n        Quantity count_{ };\n\n        enum class Action\n        {\n            Add,\n            Remove,\n            Match,\n        };\n    };\n\n    std::unordered_map<Price, LevelData> data_;\n    std::map<Price, OrderPointers, std::greater<Price>> bids_;\n    std::map<Price, OrderPointers, std::less<Price>> asks_;\n    std::unordered_map<OrderId, OrderEntry> orders_;\n    mutable std::mutex ordersMutex_;\n    std::thread ordersPruneThread_;\n    std::condition_variable shutdownConditionVariable_;\n    std::atomic<bool> shutdown_{ false };\n\n    void PruneGoodForDayOrders();\n\n    void CancelOrders(OrderIds orderIds);\n    void CancelOrderInternal(OrderId orderId);\n\n    void OnOrderCancelled(OrderPointer order);\n    void OnOrderAdded(OrderPointer order);\n    void OnOrderMatched(Price price, Quantity quantity, bool isFullyFilled);\n    void UpdateLevelData(Price price, Quantity quantity, LevelData::Action action);\n\n    bool CanFullyFill(Side side, Price price, Quantity quantity) const;\n    bool CanMatch(Side side, Price price) const;\n    Trades MatchOrders();\n\npublic:\n\n    Orderbook();\n    Orderbook(const Orderbook&) = delete;\n    void operator=(const Orderbook&) = delete;\n    Orderbook(Orderbook&&) = delete;\n    void operator=(Orderbook&&) = delete;\n    ~Orderbook();\n\n    Trades AddOrder(OrderPointer order);\n    void CancelOrder(OrderId orderId);\n    Trades ModifyOrder(OrderModify order);\n\n    std::size_t Size() const;\n    OrderbookLevelInfos GetOrderInfos() const;\n};\n"
              }
            ]
        },
        {
            "name": "8. Matching Engine",
            "overview": "Implement the core crossing logic that repeatedly matches the best bid against the best ask, executes trades at FIFO within each price level, updates per-level metadata, prunes empty levels, and enforces IOC/FAK post-conditions.",
            "deliverables": [
              {
                "task": "src/Orderbook.cpp",
                "spec": "Define the private method `Trades MatchOrders()` that produces a batch of executions by crossing top-of-book levels until no further matches are possible. It must: select best bid/ask, match front orders FIFO, fill quantities, emit trades, update level metadata, erase emptied levels, and cancel any remaining IOC (FillAndKill) order left at the top.",
                "implementation": [
                  "Guard exit conditions early: if either ladder is empty or if the best bid price is less than the best ask price, stop the loop.",
                  "Select best levels using associative container primitives: dereference `*bids_.begin()` and `*asks_.begin()` (structured bindings help readability).",
                  "Within a price-pair, match in FIFO order: access the front elements of the per-price `std::list` (`front()`), compute the execution size with `std::min(bidRemaining, askRemaining)`, and call `Fill()` on both orders.",
                  "Clean up filled orders immediately: if an order `IsFilled()`, `pop_front()` it from the list and erase its ID from `orders_` to maintain O(1) removal via the saved iterator.",
                  "Emit trade records per fill: push a `Trade` constructed from two `TradeInfo` fragments (bid and ask) into a pre-reserved `Trades` vector. Use `trades.reserve(orders_.size())` before the loop to minimize reallocations.",
                  "Bookkeeping on every fill: call `OnOrderMatched(price, quantity, isFullyFilled)` for both sides so level metadata stays correct.",
                  "Prune empty levels: after the inner FIFO loop, if a level list becomes empty, erase that price from the ladder map and remove its metadata entry from `data_`.",
                  "Handle IOC/FAK post-condition: after the outer loop, if the top resting order on either side is `OrderType::FillAndKill`, cancel it via `CancelOrder(orderId)`.",
                  "Implementation tips: use structured bindings for map entries, `std::map::erase` to drop levels, and keep the loop compact and deterministic for testability."
                ]
              }
            ],
            "learning_materials": [
              "Price–time priority: always consume from the best price first and the oldest order at that price.",
              "Deterministic matching: keeping all fills within a single loop ensures stable and testable outcomes.",
              "Housekeeping matters: removing filled orders and empty levels prevents memory and logic drift.",
              "Event-driven bookkeeping: level metadata stays correct by updating it on every match."
            ],
            "code_snippets": [
              {
                "filename": "Orderbook.cpp (MatchOrders)",
                "code": "Trades Orderbook::MatchOrders()\n{\n\tTrades trades;\n\ttrades.reserve(orders_.size());\n\n\twhile (true)\n\t{\n\t\tif (bids_.empty() || asks_.empty())\n\t\t\tbreak;\n\n\t\tauto& [bidPrice, bids] = *bids_.begin();\n\t\tauto& [askPrice, asks] = *asks_.begin();\n\n\t\tif (bidPrice < askPrice)\n\t\t\tbreak;\n\n\t\twhile (!bids.empty() && !asks.empty())\n\t\t{\n\t\t\tauto bid = bids.front();\n\t\t\tauto ask = asks.front();\n\n\t\t\tQuantity quantity = std::min(bid->GetRemainingQuantity(), ask->GetRemainingQuantity());\n\n\t\t\tbid->Fill(quantity);\n\t\t\task->Fill(quantity);\n\n\t\t\tif (bid->IsFilled())\n\t\t\t{\n\t\t\t\tbids.pop_front();\n\t\t\t\torders_.erase(bid->GetOrderId());\n\t\t\t}\n\n\t\t\tif (ask->IsFilled())\n\t\t\t{\n\t\t\t\tasks.pop_front();\n\t\t\t\torders_.erase(ask->GetOrderId());\n\t\t\t}\n\n\n\t\t\ttrades.push_back(Trade{\n\t\t\t\tTradeInfo{ bid->GetOrderId(), bid->GetPrice(), quantity },\n\t\t\t\tTradeInfo{ ask->GetOrderId(), ask->GetPrice(), quantity } \n\t\t\t\t});\n\n\t\t\tOnOrderMatched(bid->GetPrice(), quantity, bid->IsFilled());\n\t\t\tOnOrderMatched(ask->GetPrice(), quantity, ask->IsFilled());\n\t\t}\n\n        if (bids.empty())\n        {\n            bids_.erase(bidPrice);\n            data_.erase(bidPrice);\n        }\n\n        if (asks.empty())\n        {\n            asks_.erase(askPrice);\n            data_.erase(askPrice);\n        }\n\t}\n\n\tif (!bids_.empty())\n\t{\n\t\tauto& [_, bids] = *bids_.begin();\n\t\tauto& order = bids.front();\n\t\tif (order->GetOrderType() == OrderType::FillAndKill)\n\t\t\tCancelOrder(order->GetOrderId());\n\t}\n\n\tif (!asks_.empty())\n\t{\n\t\tauto& [_, asks] = *asks_.begin();\n\t\tauto& order = asks.front();\n\t\tif (order->GetOrderType() == OrderType::FillAndKill)\n\t\t\tCancelOrder(order->GetOrderId());\n\t}\n\n\treturn trades;\n}\n"
              }
            ]
        },
        {
            "name": "9. Public APIs: Add / Cancel / Modify (with Market, FAK, FOK) & Level Snapshot",
            "overview": "Expose the external interface of the order book. AddOrder admits new orders and applies order-type semantics (Market conversion, FAK, FOK). CancelOrder removes an order by ID. ModifyOrder performs cancel-and-replace while preserving the original order type. Size reports active orders, and GetOrderInfos returns an aggregate snapshot of bid/ask levels.",
            "deliverables": [
              {
                "task": "src/Orderbook.cpp",
                "spec": "Implement public methods that external callers use to interact with the book. Enforce uniqueness of OrderId, apply order-type preconditions, enqueue to the appropriate ladder, and trigger matching. Provide read-only utilities for size and level snapshots.",
                "implementation": [
                  "Thread safety: wrap all public mutators with a mutex guard (e.g., `std::scoped_lock` or `std::unique_lock`) on `ordersMutex_`.",
                  "Container utilities you’ll use in-line: `orders_.contains / .at / .erase` for the ID index; `bids_.begin / rbegin / erase` and `asks_.begin / rbegin / erase` for top-of-book and worst-price lookups; `std::prev` after `push_back` to capture the iterator of the newly enqueued order.",
                  "AddOrder flow:",
                  "  • Reject duplicates via `orders_.contains(orderId)`.",
                  "  • Market handling: if Buy and asks_ present, convert to GTC at worst ask (`*asks_.rbegin()`); if Sell and bids_ present, convert to GTC at worst bid (`*bids_.rbegin()`); if opposing side is empty, return `{}`.",
                  "  • FAK precondition: if `OrderType::FillAndKill` and `!CanMatch(side, price)`, return `{}`.",
                  "  • FOK precondition: if `OrderType::FillOrKill` and `!CanFullyFill(side, price, initialQty)`, return `{}`.",
                  "  • Enqueue to the side’s map (`bids_` or `asks_`), `push_back(order)`, capture `iterator = std::prev(orders.end())`.",
                  "  • Index in `orders_` with `{OrderPointer, iterator}` and call `OnOrderAdded(order)`.",
                  "  • Call `MatchOrders()` and return its `Trades`.",
                  "CancelOrder flow:",
                  "  • Lock, then delegate to `CancelOrderInternal(orderId)` which erases from the ladder list (via saved iterator) and from `orders_`, and triggers `OnOrderCancelled`.",
                  "ModifyOrder flow:",
                  "  • Under lock, fetch existing `OrderType` from `orders_.at(orderId)`. Unlock scope ends.",
                  "  • Call `CancelOrder(orderId)` then `AddOrder(orderModify.ToOrderPointer(orderType))`.",
                  "Size and snapshot:",
                  "  • `Size()` locks and returns `orders_.size()`.",
                  "  • `GetOrderInfos()` aggregates each price level: iterate `bids_` and `asks_`, sum remaining quantities across each list (e.g., with `std::accumulate`), and return `OrderbookLevelInfos{bidInfos, askInfos}`.",
                  "Style and readability tips:",
                  "  • Use structured bindings for map entries to keep code concise.",
                  "  • Prefer early returns on invalid/precondition-fail paths to minimize nesting."
                ]
              }
            ],
            "learning_materials": [
              "Single-path matching: converting Market to GTC at a bounded price lets the same matching logic handle all orders.",
              "Precondition checks for FAK/FOK prevent resting when policy forbids it.",
              "Stable per-level FIFO via std::list ensures price–time priority; capturing the iterator enables O(1) erasure on cancel/fill.",
              "Separating mutation (Add/Cancel/Modify) from reporting (GetOrderInfos) clarifies invariants and testability."
            ],
            "code_snippets": [
              {
                "filename": "Orderbook.cpp (AddOrder)",
                "code": "Trades Orderbook::AddOrder(OrderPointer order)\n{\n\tstd::scoped_lock ordersLock{ ordersMutex_ };\n\n\tif (orders_.contains(order->GetOrderId()))\n\t\treturn { };\n\n\tif (order->GetOrderType() == OrderType::Market)\n\t{\n\t\tif (order->GetSide() == Side::Buy && !asks_.empty())\n\t\t{\n\t\t\tconst auto& [worstAsk, _] = *asks_.rbegin();\n\t\t\torder->ToGoodTillCancel(worstAsk);\n\t\t}\n\t\telse if (order->GetSide() == Side::Sell && !bids_.empty())\n\t\t{\n\t\t\tconst auto& [worstBid, _] = *bids_.rbegin();\n\t\t\torder->ToGoodTillCancel(worstBid);\n\t\t}\n\t\telse\n\t\t\treturn { };\n\t}\n\n\tif (order->GetOrderType() == OrderType::FillAndKill && !CanMatch(order->GetSide(), order->GetPrice()))\n\t\treturn { };\n\n\tif (order->GetOrderType() == OrderType::FillOrKill && !CanFullyFill(order->GetSide(), order->GetPrice(), order->GetInitialQuantity()))\n\t\treturn { };\n\n\tOrderPointers::iterator iterator;\n\n\tif (order->GetSide() == Side::Buy)\n\t{\n\t\tauto& orders = bids_[order->GetPrice()];\n\t\torders.push_back(order);\n\t\titerator = std::prev(orders.end());\n\t}\n\telse\n\t{\n\t\tauto& orders = asks_[order->GetPrice()];\n\t\torders.push_back(order);\n\t\titerator = std::prev(orders.end());\n\t}\n\n\torders_.insert({ order->GetOrderId(), OrderEntry{ order, iterator } });\n\t\n\tOnOrderAdded(order);\n\t\n\treturn MatchOrders();\n\n}\n"
              },
              {
                "filename": "Orderbook.cpp (CancelOrder)",
                "code": "void Orderbook::CancelOrder(OrderId orderId)\n{\n\tstd::scoped_lock ordersLock{ ordersMutex_ };\n\n\tCancelOrderInternal(orderId);\n}\n"
              },
              {
                "filename": "Orderbook.cpp (ModifyOrder)",
                "code": "Trades Orderbook::ModifyOrder(OrderModify order)\n{\n\tOrderType orderType;\n\n\t{\n\t\tstd::scoped_lock ordersLock{ ordersMutex_ };\n\n\t\tif (!orders_.contains(order.GetOrderId()))\n\t\t\treturn { };\n\n\t\tconst auto& [existingOrder, _] = orders_.at(order.GetOrderId());\n\t\torderType = existingOrder->GetOrderType();\n\t}\n\n\tCancelOrder(order.GetOrderId());\n\treturn AddOrder(order.ToOrderPointer(orderType));\n}\n"
              },
              {
                "filename": "Orderbook.cpp (Size)",
                "code": "std::size_t Orderbook::Size() const\n{\n\tstd::scoped_lock ordersLock{ ordersMutex_ };\n\treturn orders_.size(); \n}\n"
              },
              {
                "filename": "Orderbook.cpp (GetOrderInfos)",
                "code": "OrderbookLevelInfos Orderbook::GetOrderInfos() const\n{\n\tLevelInfos bidInfos, askInfos;\n\tbidInfos.reserve(orders_.size());\n\taskInfos.reserve(orders_.size());\n\n\tauto CreateLevelInfos = [](Price price, const OrderPointers& orders)\n\t{\n\t\treturn LevelInfo{ price, std::accumulate(orders.begin(), orders.end(), (Quantity)0,\n\t\t\t[](Quantity runningSum, const OrderPointer& order)\n\t\t\t{ return runningSum + order->GetRemainingQuantity(); }) };\n\t};\n\n\tfor (const auto& [price, orders] : bids_)\n\t\tbidInfos.push_back(CreateLevelInfos(price, orders));\n\n\tfor (const auto& [price, orders] : asks_)\n\t\taskInfos.push_back(CreateLevelInfos(price, orders));\n\n\treturn OrderbookLevelInfos{ bidInfos, askInfos };\n\n}\n"
              }
            ]
        },
        {
            "name": "10. Good-for-Day Cancellation Service",
            "overview": "Add a background maintenance loop that cancels all GoodForDay orders at a fixed daily cutoff time. The service sleeps until the next cutoff (e.g., 16:00 local), then batches cancellations safely with minimal locking. The thread is started in the constructor and shut down cleanly in the destructor.",
            "deliverables": [
              {
                "task": "src/Orderbook.cpp",
                "spec": "Implement a private maintenance routine that schedules to the next daily deadline, wakes up (or is signaled to shut down), scans for GoodForDay orders, and cancels them in a single locked region. Ensure clean startup/shutdown semantics by starting the worker in the constructor and joining it in the destructor.",
                "implementation": [
                  "Thread lifecycle: start a worker thread in the `Orderbook` constructor that runs `PruneGoodForDayOrders()`. In the destructor, set the atomic shutdown flag, notify the condition variable, and `join()` the thread.",
                  "Time scheduling: inside `PruneGoodForDayOrders()`, compute the next local 16:00 using `<chrono>` (system_clock, hours, milliseconds) and `<ctime>` (`localtime_s`, `mktime`). If current time is past 16:00, schedule for the next day.",
                  "Sleep/wake: use a `std::condition_variable` with a `std::unique_lock<std::mutex>` to `wait_for` until the deadline or until notified for shutdown. Keep waiting work outside long critical sections.",
                  "Batch discovery: on timeout, acquire a short `std::scoped_lock` on `ordersMutex_` and scan `orders_` for entries whose `GetOrderType() == OrderType::GoodForDay`, collecting their IDs into `OrderIds`.",
                  "Batch cancel: call `CancelOrders(orderIds)` once so that removals happen under a single lock rather than per-order locks (reduces contention).",
                  "Thread-safety details: guard all shared state with `ordersMutex_`; use `shutdown_.load(memory_order_acquire)` checks in the loop.",
                  "Required primitives & includes (inline usage guidance):",
                  "  • `std::thread` to run the maintenance loop; `join()` in the destructor.",
                  "  • `std::mutex`, `std::unique_lock`, `std::scoped_lock` for critical sections.",
                  "  • `std::condition_variable::wait_for` to sleep until the next cutoff or wake on shutdown.",
                  "  • `std::atomic<bool>` to coordinate shutdown (`store`/`load`).",
                  "  • `<chrono>` utilities (`system_clock`, `hours`, `milliseconds`) and `<ctime>` (`localtime_s`, `mktime`) for wall-clock scheduling."
                ]
              }
            ],
            "learning_materials": [
              "Why batch cancellations: acquiring the mutex once to cancel many orders reduces contention and cache thrashing.",
              "Timed waits with condition variables: efficiently sleep until a deadline but allow immediate wake-up on shutdown.",
              "Local time scheduling: converting between system_clock and calendar time to target a wall-clock event.",
              "Separation of concerns: background maintenance is isolated; public APIs remain simple and responsive."
            ],
            "code_snippets": [
              {
                "filename": "Orderbook.cpp (constructor & destructor)",
                "code": "Orderbook::Orderbook() : ordersPruneThread_{ [this] { PruneGoodForDayOrders(); } } { }\n\nOrderbook::~Orderbook()\n{\n    shutdown_.store(true, std::memory_order_release);\n    shutdownConditionVariable_.notify_one();\n    ordersPruneThread_.join();\n}\n"
              },
              {
                "filename": "Orderbook.cpp (PruneGoodForDayOrders)",
                "code": "void Orderbook::PruneGoodForDayOrders()\n{    \n    using namespace std::chrono;\n    const auto end = hours(16);\n\n\twhile (true)\n\t{\n\t\tconst auto now = system_clock::now();\n\t\tconst auto now_c = system_clock::to_time_t(now);\n\t\tstd::tm now_parts;\n\t\tlocaltime_s(&now_parts, &now_c);\n\n\t\tif (now_parts.tm_hour >= end.count())\n\t\t\tnow_parts.tm_mday += 1;\n\n\t\tnow_parts.tm_hour = end.count();\n\t\tnow_parts.tm_min = 0;\n\t\tnow_parts.tm_sec = 0;\n\n\t\tauto next = system_clock::from_time_t(mktime(&now_parts));\n\t\tauto till = next - now + milliseconds(100);\n\n\t\t{\n\t\t\tstd::unique_lock ordersLock{ ordersMutex_ };\n\n\t\t\tif (shutdown_.load(std::memory_order_acquire) ||\n\t\t\t\tshutdownConditionVariable_.wait_for(ordersLock, till) == std::cv_status::no_timeout)\n\t\t\t\treturn;\n\t\t}\n\n\t\tOrderIds orderIds;\n\n\t\t{\n\t\t\tstd::scoped_lock ordersLock{ ordersMutex_ };\n\n\t\t\tfor (const auto& [_, entry] : orders_)\n\t\t\t{\n\t\t\t\tconst auto& [order, _] = entry;\n\n\t\t\t\tif (order->GetOrderType() != OrderType::GoodForDay)\n\t\t\t\t\tcontinue;\n\n\t\t\t\torderIds.push_back(order->GetOrderId());\n\t\t\t}\n\t\t}\n\n\t\tCancelOrders(orderIds);\n\t}\n}\n"
              }
            ]
        },
        {
            "name": "11. Level Metadata Bookkeeping",
            "overview": "Maintain fast, per-price aggregates (total quantity and order count) via event-style hooks so feasibility checks (e.g., FOK) and housekeeping remain O(levels) instead of O(orders). Updates happen only through centralized helpers to keep invariants consistent.",
            "deliverables": [
              {
                "task": "include/Orderbook.h",
                "spec": "Declare the LevelData structure (per-price aggregates) and the private event/update APIs that keep it in sync with order lifecycle events.",
                "implementation": [
                  "Embed a compact POD-style `struct LevelData { Quantity quantity_; Quantity count_; enum class Action { Add, Remove, Match }; };`.",
                  "Store per-price metadata in `std::unordered_map<Price, LevelData> data_` for near O(1) access keyed by price.",
                  "Declare private hooks that mirror order lifecycle transitions: `OnOrderAdded(OrderPointer)`, `OnOrderCancelled(OrderPointer)`, `OnOrderMatched(Price, Quantity, bool)`, and the central `UpdateLevelData(Price, Quantity, LevelData::Action)`.",
                  "Design notes: all aggregate mutations must flow through `UpdateLevelData` to keep arithmetic and erasure rules consistent; callers should not adjust `data_` directly."
                ]
              },
              {
                "task": "src/Orderbook.cpp",
                "spec": "Implement the event hooks so every add/cancel/fill flows through `UpdateLevelData`, which adjusts `count_` and `quantity_` consistently and erases empty levels.",
                "implementation": [
                  "On add: call `UpdateLevelData(order->GetPrice(), order->GetInitialQuantity(), Action::Add)` (use initial quantity to reflect full resting size).",
                  "On cancel: call `UpdateLevelData(order->GetPrice(), order->GetRemainingQuantity(), Action::Remove)` (only what still rested is removed).",
                  "On match: call `UpdateLevelData(price, matchedQty, isFullyFilled ? Action::Remove : Action::Match)` so `count_` decrements only when an order is fully consumed.",
                  "In `UpdateLevelData`:",
                  "  • Adjust `count_` by +1 for Add, −1 for Remove, and 0 for Match.",
                  "  • For quantity: Add → `+= quantity`; Remove/Match → `-= quantity`.",
                  "  • If `count_ == 0`, erase the price key from `data_` to keep the map minimal.",
                  "Implementation tips: use `auto& d = data_[price];` to create-or-access the bucket; keep arithmetic branchless where practical while preserving readability."
                ]
              }
            ],
            "learning_materials": [
              "Aggregating per-price metadata makes FOK checks and UI summaries efficient and decoupled from per-order structures.",
              "Event-driven updates localize complexity: all mutations to aggregates happen in one place (`UpdateLevelData`).",
              "Consistent rules: add uses initial qty; cancel uses remaining qty; match uses the actual filled qty."
            ],
            "code_snippets": [
              {
                "filename": "Orderbook.cpp (OnOrderCancelled / OnOrderAdded / OnOrderMatched / UpdateLevelData)",
                "code": "void Orderbook::OnOrderCancelled(OrderPointer order)\n{\n    UpdateLevelData(order->GetPrice(), order->GetRemainingQuantity(), LevelData::Action::Remove);\n}\n\nvoid Orderbook::OnOrderAdded(OrderPointer order)\n{\n    UpdateLevelData(order->GetPrice(), order->GetInitialQuantity(), LevelData::Action::Add);\n}\n\nvoid Orderbook::OnOrderMatched(Price price, Quantity quantity, bool isFullyFilled)\n{\n    UpdateLevelData(price, quantity, isFullyFilled ? LevelData::Action::Remove : LevelData::Action::Match);\n}\n\nvoid Orderbook::UpdateLevelData(Price price, Quantity quantity, LevelData::Action action)\n{\n    auto& data = data_[price];\n\n    data.count_ += action == LevelData::Action::Remove ? -1 : action == LevelData::Action::Add ? 1 : 0;\n    if (action == LevelData::Action::Remove || action == LevelData::Action::Match)\n    {\n        data.quantity_ -= quantity;\n    }\n    else\n    {\n        data.quantity_ += quantity;\n    }\n\n    if (data.count_ == 0)\n        data_.erase(price);\n}\n"
              }
            ]
        }                  
    ]
  }
