{
    "title": "C++ Orderbook with Advanced Order Types",
    "difficulty": "Medium",
    "timeline": "1-2 weeks",
    "description": "This project focuses on implementing a multi-order type order book from scratch using C++. An order book is a central component in financial exchanges, responsible for matching buy and sell orders. The orderbook will support various order types, going beyond the standard Good Till Cancel orders to include Fill and Kill orders.",
    "jobs": [
      { "title": "Machine Learning Engineer — NLP (Intern/Entry)", "url": "https://example.com/jobs/ml-nlp-intern" },
      { "title": "Research Engineer — Tokenization/Preprocessing", "url": "https://example.com/jobs/research-engineer-tokenization" },
      { "title": "Data Engineer — Text Processing", "url": "https://example.com/jobs/data-engineer-text" }
    ],
    "skills": [
      "C++ fundamentals",
      "Algorithms and data structures",
      "Object-oriented programming",
      "Orderbook mechanics",
      "Pointers and memory management"
    ],
    "metadata": [
        {
            "name": "1. Core Enumerations & Type Aliases",
            "overview": "Define the strongly-typed building blocks for the order book: trade side, order type, and canonical integer aliases for price, quantity, and IDs. These headers will be included across the project and must remain minimal, dependency-light, and consistent.",
            "what_and_how": [
              {
                "file": "Side.h",
                "spec": "Provide a scoped enumeration for the trade direction.",
                "how_to_implement": [
                  "Use enum class (scoped) to prevent implicit conversions and name collisions.",
                  "Keep the header minimal: #pragma once and the enum declaration only.",
                  "Names should be clear and stable across the codebase (e.g., Buy, Sell)."
                ]
              },
              {
                "file": "OrderType.h",
                "spec": "Provide a scoped enumeration for supported order behaviors used throughout matching and policy checks.",
                "how_to_implement": [
                  "Use enum class to keep types safe and explicit.",
                  "Include all order types that appear throughout the engine (GTC/IOC(FAK)/FOK/GFD/Market).",
                  "Keep it header-only; no functions or extras."
                ]
              },
              {
                "file": "Usings.h",
                "spec": "Define fixed-width aliases used everywhere for prices, quantities, and order IDs, plus a small container of IDs.",
                "how_to_implement": [
                  "Create using aliases: Price, Quantity, OrderId.",
                  "Define OrderIds as std::vector<OrderId>.",
                  "Keep the header very small; only include what’s necessary for the aliases (in the repo, only <vector> is included)."
                ]
              }
            ],
            "required_skills": [
              "C++ header hygiene (#pragma once, minimal includes)",
              "Scoped enumerations (enum class)",
              "Type aliasing with using",
              "Basic STL containers (std::vector)"
            ],
            "learning_materials": [
              "Why enum class? Scoped enums avoid accidental int conversions and reduce naming conflicts.",
              "using aliases encode domain semantics (Price, Quantity, OrderId) and enable easy type refactoring later.",
              "Keep foundational headers tiny and dependency-light to avoid circular includes and speed up builds.",
              "Consistent, fixed-width integer usage is important for determinism across platforms."
            ],
            "c++_functions": [
              "enum class (scoped enumerations)",
              "using (type aliases)",
              "STL: std::vector",
              "Fixed-width integer types (e.g., std::int32_t, std::uint32_t, std::uint64_t)"
            ],
            "code_snippets": [
              {
                "filename": "Side.h",
                "code": "#pragma once\n\nenum class Side\n{\n    Buy,\n    Sell\n};\n"
              },
              {
                "filename": "OrderType.h",
                "code": "#pragma once\n\nenum class OrderType\n{\n\tGoodTillCancel,\n\tFillAndKill,\n\tFillOrKill,\n\tGoodForDay,\n\tMarket,\n};\n"
              },
              {
                "filename": "Usings.h",
                "code": "#pragma once\n\n#include <vector>\n\nusing Price = std::int32_t;\nusing Quantity = std::uint32_t;\nusing OrderId = std::uint64_t;\nusing OrderIds = std::vector<OrderId>;\n"
              }
            ]
        },
        {
            "name": "2. Constants",
            "overview": "Centralize sentinel values used throughout the engine (e.g., an invalid price) in a tiny header so all components share a single source of truth.",
            "what_and_how": [
              {
                "file": "include/Constants.h",
                "spec": "Expose project-wide constant(s) such as an invalid price sentinel to indicate an unset or unusable value.",
                "how_to_implement": [
                  "Create a lightweight header with `#pragma once`.",
                  "Include the aliases header first (for `Price`) and `<limits>` for type traits.",
                  "Define a small holder (e.g., a `struct`) and declare the sentinel as a class static data member, matching the repository style.",
                  "Keep dependencies minimal so this header is safe to include from anywhere."
                ]
              }
            ],
            "required_skills": [
              "C++ header hygiene (`#pragma once`, minimal includes)",
              "Using standard type traits via `<limits>`",
              "Declaring static class data members in headers"
            ],
            "learning_materials": [
              "Why centralize sentinels: prevents scattered magic numbers and keeps validation consistent.",
              "Header-only constants: enable broad reuse without extra translation units.",
              "Sentinel semantics: an invalid value communicates 'unset' or 'not applicable' through types rather than ad hoc checks."
            ],
            "c++_functions": [
              "std::numeric_limits<T>",
              "Header includes: <limits>",
              "Static data members inside a struct/class"
            ],
            "code_snippets": [
              {
                "filename": "Constants.h",
                "code": "#pragma once\n\n#include <limits>\n\n#include \"Usings.h\"\n\nstruct Constants\n{\n    static const Price InvalidPrice = std::numeric_limits<Price>::quiet_NaN();\n};\n"
              }
            ]
        },
        {
            "name": "3. Level Types & Aggregated Views",
            "overview": "Define simple, POD-style structures to represent per-price aggregated quantities and expose a read-only snapshot of the order book's bid and ask levels. These types are used by the order book to report state for testing, monitoring, or UI display without exposing internal storage details.",
            "what_and_how": [
              {
                "file": "include/LevelInfo.h",
                "spec": "A lightweight struct holding a price and the total remaining quantity at that price level, plus an alias for a collection of levels.",
                "how_to_implement": [
                  "Keep the struct trivial (plain fields) for easy copying and debugging.",
                  "Include the shared type aliases so Price and Quantity are consistent across the project.",
                  "Provide a `using LevelInfos = std::vector<LevelInfo>;` alias for convenience when returning multiple levels."
                ]
              },
              {
                "file": "include/OrderbookLevelInfos.h",
                "spec": "A small wrapper that bundles bid and ask `LevelInfos` and exposes const getters, serving as the read-only snapshot type returned by the order book.",
                "how_to_implement": [
                  "Store two `LevelInfos` members: one for bids and one for asks.",
                  "Initialize both via a constructor to keep the object valid upon creation.",
                  "Expose const accessors (`GetBids`, `GetAsks`) and avoid mutating methods to preserve snapshot semantics."
                ]
              }
            ],
            "required_skills": [
              "C++ structs and simple classes",
              "Using STL containers (std::vector)",
              "Header hygiene (#pragma once, minimal includes)",
              "Const-correctness for accessor methods"
            ],
            "learning_materials": [
              "Aggregated level views separate external reporting from internal storage (lists/maps), reducing coupling.",
              "Plain-old-data (POD) structs are easy to pass by value, serialize, and log.",
              "Returning const references from getters encourages immutable snapshot patterns."
            ],
            "c++_functions": [
              "Struct and class definitions",
              "Constructor initialization lists",
              "STL: std::vector",
              "Const-qualified member functions"
            ],
            "code_snippets": [
              {
                "filename": "LevelInfo.h",
                "code": "#pragma once\n\n#include \"Usings.h\"\n\nstruct LevelInfo\n{\n    Price price_;\n    Quantity quantity_;\n};\n\nusing LevelInfos = std::vector<LevelInfo>;\n"
              },
              {
                "filename": "OrderbookLevelInfos.h",
                "code": "#pragma once\n\n#include \"LevelInfo.h\"\n\nclass OrderbookLevelInfos\n{\npublic:\n    OrderbookLevelInfos(const LevelInfos& bids, const LevelInfos& asks)\n        : bids_{ bids }\n        , asks_{ asks }\n    { }\n\n    const LevelInfos& GetBids() const { return bids_; }\n    const LevelInfos& GetAsks() const { return asks_; }\n\nprivate:\n    LevelInfos bids_;\n    LevelInfos asks_;\n};\n"
              }
            ]
        },
        {
            "name": "4. Trade Records",
            "overview": "Introduce lightweight types to represent executed trades. Each match produces two trade fragments—one for the bid and one for the ask—which are bundled into a single Trade object. A collection of these is returned by the matching engine to describe what executed.",
            "what_and_how": [
              {
                "file": "include/TradeInfo.h",
                "spec": "A plain struct describing one side of a trade: which order participated, at what price, and for what quantity.",
                "how_to_implement": [
                  "Keep it POD-style (no methods) for easy copying, logging, and testing.",
                  "Include the shared aliases header so `OrderId`, `Price`, and `Quantity` are consistent across the project.",
                  "Name fields clearly to match their semantics (order id, execution price, matched quantity)."
                ]
              },
              {
                "file": "include/Trade.h",
                "spec": "A small class that bundles two TradeInfo records—bid and ask—into a single Trade object, plus a convenient alias for a vector of trades.",
                "how_to_implement": [
                  "Store two private `TradeInfo` members for the bid and ask sides; initialize via a simple constructor.",
                  "Expose const accessors for read-only retrieval.",
                  "Provide a `using Trades = std::vector<Trade>;` alias to represent batches of executions."
                ]
              }
            ],
            "required_skills": [
              "C++ header hygiene (#pragma once, minimal includes)",
              "Structs and small classes",
              "Constructor initialization lists",
              "STL containers (std::vector)"
            ],
            "learning_materials": [
              "Trade events are inherently two-sided; modeling both sides explicitly simplifies auditing and testing.",
              "Keeping TradeInfo as a POD makes it trivial to store, log, and serialize.",
              "Returning a `std::vector<Trade>` allows the matcher to report sweeps (multiple fills from a single incoming order)."
            ],
            "c++_functions": [
              "Struct and class definitions",
              "Constructor initialization list",
              "STL: std::vector"
            ],
            "code_snippets": [
              {
                "filename": "TradeInfo.h",
                "code": "#pragma once\n\n#include \"Usings.h\"\n\nstruct TradeInfo\n{\n    OrderId orderId_;\n    Price price_;\n    Quantity quantity_;\n};\n"
              },
              {
                "filename": "Trade.h",
                "code": "#pragma once\n\n#include \"TradeInfo.h\"\n\nclass Trade\n{\npublic:\n    Trade(const TradeInfo& bidTrade, const TradeInfo& askTrade)\n        : bidTrade_{ bidTrade }\n        , askTrade_{ askTrade }\n    { }\n\n    const TradeInfo& GetBidTrade() const { return bidTrade_; }\n    const TradeInfo& GetAskTrade() const { return askTrade_; }\n\nprivate:\n    TradeInfo bidTrade_;\n    TradeInfo askTrade_;\n};\n\nusing Trades = std::vector<Trade>;\n"
              }
            ]
        },
        {
            "name": "5. The Order Object",
            "overview": "Implement the core Order type that models a single instruction on the book. It owns immutable identity (order id, side, type, price at creation) and mutable state (remaining quantity). It provides safe fill semantics, derived status accessors, and a helper to convert Market orders into GoodTillCancel limits at runtime.",
            "what_and_how": [
              {
                "file": "include/Order.h",
                "spec": "Declare the Order class with constructors for limit and market orders, read-only accessors, a safe Fill method, and a Market→GTC conversion helper. Also expose storage aliases used by the book (shared_ptr + list).",
                "how_to_implement": [
                  "Include headers for enums (OrderType.h, Side.h), aliases (Usings.h), constants (Constants.h), and standard utilities (`<list>`, `<exception>`, `<format>`).",
                  "Store `OrderType`, `OrderId`, `Side`, `Price`, `Quantity initialQuantity_`, and `Quantity remainingQuantity_` as private members.",
                  "Provide two constructors: (1) full constructor for any type; (2) convenience constructor for Market initializing price to the invalid sentinel.",
                  "Expose const accessors for id, side, price, type, initial/remaining quantities, and derived filled quantity; add `IsFilled()`.",
                  "Implement `Fill(Quantity)` to decrease remaining quantity with bounds checking; throw on overfill.",
                  "Implement `ToGoodTillCancel(Price)` to convert a Market order to a priced GTC order; throw if called on non-Market."
                ]
              }
            ],
            "required_skills": [
              "C++ class design (constructors, member initialization, accessors)",
              "Exception handling (`std::logic_error`)",
              "C++20 text formatting (`std::format`)",
              "Smart pointers (`std::shared_ptr`) and container selection (`std::list`)"
            ],
            "learning_materials": [
              "Price–time priority requires stable iterators at each price level; `std::list` preserves iterator validity as orders append.",
              "Derived state (`filled = initial - remaining`) avoids consistency bugs versus storing a separate filled member.",
              "Market orders start unpriced; converting them to GTC at the worst opposing price routes all matching through one path.",
              "Defensive programming: validate mutations (e.g., `Fill`) and signal misuse via exceptions with clear diagnostics."
            ],
            "c++_functions": [
              "Constructors and member initializer lists",
              "Const-qualified getters",
              "`std::logic_error` (exceptions)",
              "`std::format` (C++20 formatting)",
              "`std::shared_ptr`, `std::make_shared`",
              "`std::list` (stable iterators for per-price FIFO queues)"
            ],
            "implementation_api_contract": {
              "constructors": [
                "Order(OrderType orderType, OrderId orderId, Side side, Price price, Quantity quantity)",
                "Order(OrderId orderId, Side side, Quantity quantity)  // Market convenience ctor"
              ],
              "accessors": [
                "OrderId GetOrderId() const",
                "Side GetSide() const",
                "Price GetPrice() const",
                "OrderType GetOrderType() const",
                "Quantity GetInitialQuantity() const",
                "Quantity GetRemainingQuantity() const",
                "Quantity GetFilledQuantity() const",
                "bool IsFilled() const"
              ],
              "mutators_and_helpers": [
                "void Fill(Quantity quantity)  // throws std::logic_error if quantity > remaining",
                "void ToGoodTillCancel(Price price)  // throws if orderType != Market"
              ],
              "aliases": [
                "using OrderPointer = std::shared_ptr<Order>;",
                "using OrderPointers = std::list<OrderPointer>;"
              ],
              "includes": [
                "<list>",
                "<exception>",
                "<format>",
                "\"OrderType.h\"",
                "\"Side.h\"",
                "\"Usings.h\"",
                "\"Constants.h\""
              ]
            },
            "code_snippets": [
              {
                "filename": "Order.h",
                "code": "#pragma once\n\n#include <list>\n#include <exception>\n#include <format>\n\n#include \"OrderType.h\"\n#include \"Side.h\"\n#include \"Usings.h\"\n#include \"Constants.h\"\n\n\nclass Order\n{\npublic:\n    Order(OrderType orderType, OrderId orderId, Side side, Price price, Quantity quantity)\n        : orderType_{ orderType }\n        , orderId_{ orderId }\n        , side_{ side }\n        , price_{ price }\n        , initialQuantity_{ quantity }\n        , remainingQuantity_{ quantity }\n    { }\n\n    Order(OrderId orderId, Side side, Quantity quantity)\n        : Order(OrderType::Market, orderId, side, Constants::InvalidPrice, quantity)\n    { }\n\n    OrderId GetOrderId() const { return orderId_; }\n    Side GetSide() const { return side_; }\n    Price GetPrice() const { return price_; }\n    OrderType GetOrderType() const { return orderType_; }\n    Quantity GetInitialQuantity() const { return initialQuantity_; }\n    Quantity GetRemainingQuantity() const { return remainingQuantity_; }\n    Quantity GetFilledQuantity() const { return GetInitialQuantity() - GetRemainingQuantity(); }\n    bool IsFilled() const { return GetRemainingQuantity() == 0; }\n    void Fill(Quantity quantity)\n    {\n        if (quantity > GetRemainingQuantity())\n            throw std::logic_error(std::format(\"Order ({}) cannot be filled for more than its remaining quantity.\", GetOrderId()));\n\n        remainingQuantity_ -= quantity;\n    }\n    void ToGoodTillCancel(Price price) \n    { \n        if (GetOrderType() != OrderType::Market)\n            throw std::logic_error(std::format(\"Order ({}) cannot have its price adjusted, only market orders can.\", GetOrderId()));\n\n        price_ = price;\n        orderType_ = OrderType::GoodTillCancel;\n    }\n\nprivate:\n    OrderType orderType_;\n    OrderId orderId_;\n    Side side_;\n    Price price_;\n    Quantity initialQuantity_;\n    Quantity remainingQuantity_;\n};\n\nusing OrderPointer = std::shared_ptr<Order>;\nusing OrderPointers = std::list<OrderPointer>;\n"
              }
            ]
        },
        {
            "name": "6. Order Modification",
            "overview": "Provide a lightweight value type to represent cancel-and-replace semantics. This object carries the new desired fields (price, side, quantity) for an existing order ID and can materialize a fresh Order instance while preserving the original order type.",
            "what_and_how": [
              {
                "file": "include/OrderModify.h",
                "spec": "Declare a small class that stores OrderId, Side, Price, and Quantity, exposes trivial getters, and provides a factory method to create a new Order from these fields while accepting an explicit OrderType.",
                "how_to_implement": [
                  "Include \"Order.h\" so you can construct new orders and return OrderPointer.",
                  "Store four private members: orderId_, price_, side_, quantity_.",
                  "Provide a simple constructor initializing all four members.",
                  "Expose const getters for each field to keep the object immutable from the outside.",
                  "Implement ToOrderPointer(OrderType type) using std::make_shared<Order>(...) to produce a new order that reuses the same OrderId and applies the current Side/Price/Quantity."
                ]
              }
            ],
            "required_skills": [
              "C++ class design (value types, constructors, accessors)",
              "Header hygiene (#pragma once, minimal includes)",
              "Smart pointers (std::shared_ptr) and factories (std::make_shared)"
            ],
            "learning_materials": [
              "Cancel-and-replace flows: most matching engines implement modification as a logical cancel of the old order followed by the addition of a new order.",
              "Immutability at the edge: keeping OrderModify as a simple value object avoids partial updates and makes the API easy to reason about.",
              "Separation of concerns: OrderModify describes intent; Orderbook owns the actual cancel and re-add logic."
            ],
            "c++_functions": [
              "Constructors and member initializer lists",
              "Const-qualified getters",
              "std::make_shared (factory for std::shared_ptr)"
            ],
            "code_snippets": [
              {
                "filename": "OrderModify.h",
                "code": "#pragma once\n\n#include \"Order.h\"\n\nclass OrderModify\n{\npublic:\n    OrderModify(OrderId orderId, Side side, Price price, Quantity quantity)\n        : orderId_{ orderId }\n        , price_{ price }\n        , side_{ side }\n        , quantity_{ quantity }\n    { }\n\n    OrderId GetOrderId() const { return orderId_; }\n    Price GetPrice() const { return price_; }\n    Side GetSide() const { return side_; }\n    Quantity GetQuantity() const { return quantity_; }\n\n    OrderPointer ToOrderPointer(OrderType type) const\n    {\n        return std::make_shared<Order>(type, GetOrderId(), GetSide(), GetPrice(), GetQuantity());\n    }\n\nprivate:\n    OrderId orderId_;\n    Price price_;\n    Side side_;\n    Quantity quantity_;\n};\n"
              }
            ]
        },
        {
            "name": "7. Orderbook: Internal Storage & Private APIs",
            "overview": "Define the in-memory structure of the matching engine and its private helpers. This header declares price ladders for bids/asks, an O(1) order index for fast cancels/modifies, per-price level metadata for bookkeeping and FOK checks, and internal methods for matching and maintenance.",
            "what_and_how": [
              {
                "file": "include/Orderbook.h",
                "spec": "Declare the Orderbook class with all internal data structures and private APIs required by the engine. Include nested helper structs for order location and per-level aggregates, ordered maps for price ladders, an ID index, and concurrency members for the GFD pruning thread.",
                "how_to_implement": [
                  "Use two ordered maps for the price ladders: bids sorted with std::greater<Price> (best bid first) and asks sorted with std::less<Price> (best ask first). Each price maps to a std::list of shared_ptr<Order> to preserve FIFO and stable iterators.",
                  "Maintain an O(1) lookup from OrderId to an OrderEntry that holds both the OrderPointer and its list iterator for fast erasure during cancels/fills.",
                  "Track per-price metadata (LevelData) to keep aggregate quantity and count current via event hooks; store it in an unordered_map keyed by Price.",
                  "Expose private helper methods: CanMatch, CanFullyFill, MatchOrders for core matching logic; OnOrderAdded/Cancelled/Matched and UpdateLevelData for bookkeeping; CancelOrders/CancelOrderInternal for internal removals; PruneGoodForDayOrders for scheduled cleanup.",
                  "Add thread-safety primitives: a mutex protecting state, a condition_variable and atomic flag for clean shutdown of the GFD pruning thread. Delete copy/move to avoid accidental sharing of internal state."
                ]
              }
            ],
            "required_skills": [
              "C++ STL associative containers (std::map with custom comparators; std::unordered_map)",
              "Linked-list iterators (std::list) and iterator stability",
              "RAII locking (std::scoped_lock, std::unique_lock), condition variables, and std::atomic<bool>",
              "Designing private helper APIs and invariants for matching engines"
            ],
            "learning_materials": [
              "Price–time priority: ordered maps (bids desc, asks asc) plus per-price FIFO queues preserve market semantics.",
              "OrderEntry (pointer + iterator) enables O(1) cancels/modifies without scanning a price level.",
              "LevelData aggregates ({quantity, count}) allow fast feasibility checks (e.g., FOK) and consistent housekeeping.",
              "Background services (e.g., GFD pruning) require clear ownership and shutdown protocols to avoid races or leaks."
            ],
            "c++_functions": [
              "std::map with std::greater<T>/std::less<T> comparators",
              "std::unordered_map for O(1) keyed lookups",
              "std::list and iterators for FIFO per price level",
              "std::scoped_lock, std::unique_lock, std::condition_variable",
              "std::atomic<bool> for thread-safe flags"
            ],
            "code_snippets": [
              {
                "filename": "Orderbook.h",
                "code": "#pragma once\n\n#include <map>\n#include <unordered_map>\n#include <thread>\n#include <condition_variable>\n#include <mutex>\n\n#include \"Usings.h\"\n#include \"Order.h\"\n#include \"OrderModify.h\"\n#include \"OrderbookLevelInfos.h\"\n#include \"Trade.h\"\n\nclass Orderbook\n{\nprivate:\n\n    struct OrderEntry\n    {\n        OrderPointer order_{ nullptr };\n        OrderPointers::iterator location_;\n    };\n\n    struct LevelData\n    {\n        Quantity quantity_{ };\n        Quantity count_{ };\n\n        enum class Action\n        {\n            Add,\n            Remove,\n            Match,\n        };\n    };\n\n    std::unordered_map<Price, LevelData> data_;\n    std::map<Price, OrderPointers, std::greater<Price>> bids_;\n    std::map<Price, OrderPointers, std::less<Price>> asks_;\n    std::unordered_map<OrderId, OrderEntry> orders_;\n    mutable std::mutex ordersMutex_;\n    std::thread ordersPruneThread_;\n    std::condition_variable shutdownConditionVariable_;\n    std::atomic<bool> shutdown_{ false };\n\n    void PruneGoodForDayOrders();\n\n    void CancelOrders(OrderIds orderIds);\n    void CancelOrderInternal(OrderId orderId);\n\n    void OnOrderCancelled(OrderPointer order);\n    void OnOrderAdded(OrderPointer order);\n    void OnOrderMatched(Price price, Quantity quantity, bool isFullyFilled);\n    void UpdateLevelData(Price price, Quantity quantity, LevelData::Action action);\n\n    bool CanFullyFill(Side side, Price price, Quantity quantity) const;\n    bool CanMatch(Side side, Price price) const;\n    Trades MatchOrders();\n\npublic:\n\n    Orderbook();\n    Orderbook(const Orderbook&) = delete;\n    void operator=(const Orderbook&) = delete;\n    Orderbook(Orderbook&&) = delete;\n    void operator=(Orderbook&&) = delete;\n    ~Orderbook();\n\n    Trades AddOrder(OrderPointer order);\n    void CancelOrder(OrderId orderId);\n    Trades ModifyOrder(OrderModify order);\n\n    std::size_t Size() const;\n    OrderbookLevelInfos GetOrderInfos() const;\n};\n"
              }
            ]
        },
        {
            "name": "8. Matching Engine (Core Loop)",
            "overview": "Implement the core crossing logic that repeatedly matches the best bid against the best ask, executes trades at FIFO within each price level, updates per-level metadata, prunes empty levels, and enforces IOC/FAK post-conditions.",
            "what_and_how": [
              {
                "file": "src/Orderbook.cpp",
                "spec": "Define a private method that produces a batch of executions by crossing top-of-book levels until no further matches are possible. It must: select best bid/ask, match front orders FIFO, fill quantities, emit trades, update level metadata, erase emptied levels, and cancel any remaining IOC (FillAndKill) order left at the top.",
                "how_to_implement": [
                  "Guard against empty ladders: exit when either side is empty or when bestBid < bestAsk.",
                  "Operate at the best levels only: use `*bids_.begin()` and `*asks_.begin()` to reference best price buckets.",
                  "Within each best price pair, match the front orders (FIFO) using `std::min(remainingBid, remainingAsk)`; call `Fill()` on both.",
                  "Erase filled orders from both the per-price list and the global `orders_` index; if a price list becomes empty, erase that price level and its metadata entry.",
                  "For every fill, create a `Trade` with two `TradeInfo` records (bid side and ask side) and push it into the `Trades` vector.",
                  "Notify per-level bookkeeping through `OnOrderMatched(price, qty, isFullyFilled)` for both sides.",
                  "After the crossing loop, if the best resting order is `FillAndKill`, cancel it using `CancelOrder`."
                ]
              }
            ],
            "required_skills": [
              "Associative container traversal (std::map begin/rbegin, structured bindings)",
              "Linked-list queue operations (front/pop_front) on per-price lists",
              "Safe state mutation and invariant maintenance across multiple containers",
              "Batching outputs into a result vector without unnecessary reallocations"
            ],
            "learning_materials": [
              "Price–time priority: always consume from the best price first and the oldest order at that price.",
              "Deterministic matching: keeping all fills within a single loop ensures stable and testable outcomes.",
              "Housekeeping matters: removing filled orders and empty levels prevents memory and logic drift.",
              "Event-driven bookkeeping: level metadata stays correct by updating it on every match."
            ],
            "c++_functions": [
              "std::map::begin(), std::map::rbegin(), std::map::erase()",
              "std::list::front(), std::list::pop_front(), std::list::empty()",
              "std::min() for fill quantity selection",
              "Structured bindings (C++17) for map entries",
              "Vector reservation (`trades.reserve(...)`) to reduce reallocations"
            ],
            "code_snippets": [
              {
                "filename": "Orderbook.cpp (MatchOrders)",
                "code": "Trades Orderbook::MatchOrders()\n{\n\tTrades trades;\n\ttrades.reserve(orders_.size());\n\n\twhile (true)\n\t{\n\t\tif (bids_.empty() || asks_.empty())\n\t\t\tbreak;\n\n\t\tauto& [bidPrice, bids] = *bids_.begin();\n\t\tauto& [askPrice, asks] = *asks_.begin();\n\n\t\tif (bidPrice < askPrice)\n\t\t\tbreak;\n\n\t\twhile (!bids.empty() && !asks.empty())\n\t\t{\n\t\t\tauto bid = bids.front();\n\t\t\tauto ask = asks.front();\n\n\t\t\tQuantity quantity = std::min(bid->GetRemainingQuantity(), ask->GetRemainingQuantity());\n\n\t\t\tbid->Fill(quantity);\n\t\t\task->Fill(quantity);\n\n\t\t\tif (bid->IsFilled())\n\t\t\t{\n\t\t\t\tbids.pop_front();\n\t\t\t\torders_.erase(bid->GetOrderId());\n\t\t\t}\n\n\t\t\tif (ask->IsFilled())\n\t\t\t{\n\t\t\t\tasks.pop_front();\n\t\t\t\torders_.erase(ask->GetOrderId());\n\t\t\t}\n\n\n\t\t\ttrades.push_back(Trade{\n\t\t\t\tTradeInfo{ bid->GetOrderId(), bid->GetPrice(), quantity },\n\t\t\t\tTradeInfo{ ask->GetOrderId(), ask->GetPrice(), quantity } \n\t\t\t\t});\n\n\t\t\tOnOrderMatched(bid->GetPrice(), quantity, bid->IsFilled());\n\t\t\tOnOrderMatched(ask->GetPrice(), quantity, ask->IsFilled());\n\t\t}\n\n        if (bids.empty())\n        {\n            bids_.erase(bidPrice);\n            data_.erase(bidPrice);\n        }\n\n        if (asks.empty())\n        {\n            asks_.erase(askPrice);\n            data_.erase(askPrice);\n        }\n\t}\n\n\tif (!bids_.empty())\n\t{\n\t\tauto& [_, bids] = *bids_.begin();\n\t\tauto& order = bids.front();\n\t\tif (order->GetOrderType() == OrderType::FillAndKill)\n\t\t\tCancelOrder(order->GetOrderId());\n\t}\n\n\tif (!asks_.empty())\n\t{\n\t\tauto& [_, asks] = *asks_.begin();\n\t\tauto& order = asks.front();\n\t\tif (order->GetOrderType() == OrderType::FillAndKill)\n\t\t\tCancelOrder(order->GetOrderId());\n\t}\n\n\treturn trades;\n}\n"
              }
            ]
        },
        {
            "name": "9. Public APIs: Add / Cancel / Modify (with Market, FAK, FOK) & Level Snapshot",
            "overview": "Expose the external interface of the order book. AddOrder admits new orders and applies order-type semantics (Market conversion, FAK, FOK). CancelOrder removes an order by ID. ModifyOrder performs cancel-and-replace while preserving the original order type. Size reports active orders, and GetOrderInfos returns an aggregate snapshot of bid/ask levels.",
            "what_and_how": [
              {
                "file": "src/Orderbook.cpp",
                "spec": "Implement public methods that external callers use to interact with the book. Enforce uniqueness of OrderId, apply order-type preconditions, enqueue to the appropriate ladder, and trigger matching. Provide read-only utilities for size and level snapshots.",
                "how_to_implement": [
                  "Guard public mutating methods with a lock (scoped/unique) on the shared state mutex.",
                  "In AddOrder: reject duplicate OrderIds; convert Market to GoodTillCancel at the worst opposing price (if the opposing side exists), otherwise return empty trades; enforce FillAndKill precondition via CanMatch; enforce FillOrKill via CanFullyFill; enqueue to the correct side while capturing a list iterator; index into orders_ and fire OnOrderAdded; then call MatchOrders and return Trades.",
                  "In CancelOrder: lock and delegate to CancelOrderInternal to erase from ladders + index, and update level metadata via OnOrderCancelled.",
                  "In ModifyOrder: under lock, fetch the current OrderType; then cancel and re-add using OrderModify::ToOrderPointer(orderType).",
                  "In Size: lock and return orders_.size().",
                  "In GetOrderInfos: aggregate remaining quantities per price level across bids_ and asks_, and return an OrderbookLevelInfos snapshot."
                ]
              }
            ],
            "required_skills": [
              "Thread-safe public API design (mutex locking strategy)",
              "Applying order-type semantics (Market/FAK/FOK) before enqueueing",
              "Associative container operations (maps, unordered_map) with iterators",
              "Aggregation over containers (accumulate/loops) for read-only snapshots"
            ],
            "learning_materials": [
              "Single-path matching: converting Market to GTC at a bounded price lets the same matching logic handle all orders.",
              "Precondition checks for FAK/FOK prevent resting when policy forbids it.",
              "Stable per-level FIFO via std::list ensures price–time priority; capturing the iterator enables O(1) erasure on cancel/fill.",
              "Separating mutation (Add/Cancel/Modify) from reporting (GetOrderInfos) clarifies invariants and testability."
            ],
            "c++_functions": [
              "std::scoped_lock / std::unique_lock for mutex protection",
              "std::unordered_map::contains / ::at / ::erase",
              "std::map::rbegin / ::begin / ::erase",
              "std::prev (to capture list back iterator after push_back)",
              "std::accumulate for aggregations",
              "Structured bindings for map entries"
            ],
            "code_snippets": [
              {
                "filename": "Orderbook.cpp (AddOrder)",
                "code": "Trades Orderbook::AddOrder(OrderPointer order)\n{\n\tstd::scoped_lock ordersLock{ ordersMutex_ };\n\n\tif (orders_.contains(order->GetOrderId()))\n\t\treturn { };\n\n\tif (order->GetOrderType() == OrderType::Market)\n\t{\n\t\tif (order->GetSide() == Side::Buy && !asks_.empty())\n\t\t{\n\t\t\tconst auto& [worstAsk, _] = *asks_.rbegin();\n\t\t\torder->ToGoodTillCancel(worstAsk);\n\t\t}\n\t\telse if (order->GetSide() == Side::Sell && !bids_.empty())\n\t\t{\n\t\t\tconst auto& [worstBid, _] = *bids_.rbegin();\n\t\t\torder->ToGoodTillCancel(worstBid);\n\t\t}\n\t\telse\n\t\t\treturn { };\n\t}\n\n\tif (order->GetOrderType() == OrderType::FillAndKill && !CanMatch(order->GetSide(), order->GetPrice()))\n\t\treturn { };\n\n\tif (order->GetOrderType() == OrderType::FillOrKill && !CanFullyFill(order->GetSide(), order->GetPrice(), order->GetInitialQuantity()))\n\t\treturn { };\n\n\tOrderPointers::iterator iterator;\n\n\tif (order->GetSide() == Side::Buy)\n\t{\n\t\tauto& orders = bids_[order->GetPrice()];\n\t\torders.push_back(order);\n\t\titerator = std::prev(orders.end());\n\t}\n\telse\n\t{\n\t\tauto& orders = asks_[order->GetPrice()];\n\t\torders.push_back(order);\n\t\titerator = std::prev(orders.end());\n\t}\n\n\torders_.insert({ order->GetOrderId(), OrderEntry{ order, iterator } });\n\t\n\tOnOrderAdded(order);\n\t\n\treturn MatchOrders();\n\n}\n"
              },
              {
                "filename": "Orderbook.cpp (CancelOrder)",
                "code": "void Orderbook::CancelOrder(OrderId orderId)\n{\n\tstd::scoped_lock ordersLock{ ordersMutex_ };\n\n\tCancelOrderInternal(orderId);\n}\n"
              },
              {
                "filename": "Orderbook.cpp (ModifyOrder)",
                "code": "Trades Orderbook::ModifyOrder(OrderModify order)\n{\n\tOrderType orderType;\n\n\t{\n\t\tstd::scoped_lock ordersLock{ ordersMutex_ };\n\n\t\tif (!orders_.contains(order.GetOrderId()))\n\t\t\treturn { };\n\n\t\tconst auto& [existingOrder, _] = orders_.at(order.GetOrderId());\n\t\torderType = existingOrder->GetOrderType();\n\t}\n\n\tCancelOrder(order.GetOrderId());\n\treturn AddOrder(order.ToOrderPointer(orderType));\n}\n"
              },
              {
                "filename": "Orderbook.cpp (Size)",
                "code": "std::size_t Orderbook::Size() const\n{\n\tstd::scoped_lock ordersLock{ ordersMutex_ };\n\treturn orders_.size(); \n}\n"
              },
              {
                "filename": "Orderbook.cpp (GetOrderInfos)",
                "code": "OrderbookLevelInfos Orderbook::GetOrderInfos() const\n{\n\tLevelInfos bidInfos, askInfos;\n\tbidInfos.reserve(orders_.size());\n\taskInfos.reserve(orders_.size());\n\n\tauto CreateLevelInfos = [](Price price, const OrderPointers& orders)\n\t{\n\t\treturn LevelInfo{ price, std::accumulate(orders.begin(), orders.end(), (Quantity)0,\n\t\t\t[](Quantity runningSum, const OrderPointer& order)\n\t\t\t{ return runningSum + order->GetRemainingQuantity(); }) };\n\t};\n\n\tfor (const auto& [price, orders] : bids_)\n\t\tbidInfos.push_back(CreateLevelInfos(price, orders));\n\n\tfor (const auto& [price, orders] : asks_)\n\t\taskInfos.push_back(CreateLevelInfos(price, orders));\n\n\treturn OrderbookLevelInfos{ bidInfos, askInfos };\n\n}\n"
              }
            ]
        },
        {
            "name": "10. Good-for-Day (GFD) Cancellation Service",
            "overview": "Add a background maintenance loop that cancels all GoodForDay orders at a fixed daily cutoff time. The service sleeps until the next cutoff (e.g., 16:00 local), then batches cancellations safely with minimal locking. The thread is started in the constructor and shut down cleanly in the destructor.",
            "what_and_how": [
              {
                "file": "src/Orderbook.cpp",
                "spec": "Implement a private maintenance routine that schedules to the next daily deadline, wakes up (or is signaled to shut down), scans for GoodForDay orders, and cancels them in a single locked region. Ensure clean startup/shutdown semantics by starting the worker in the constructor and joining it in the destructor.",
                "how_to_implement": [
                  "Start a worker thread in the `Orderbook` constructor that runs `PruneGoodForDayOrders()`.",
                  "In `PruneGoodForDayOrders()`, compute the next local 16:00 using `<chrono>` and `<ctime>` utilities.",
                  "Use a `std::condition_variable` to sleep until the deadline or shutdown signal while holding a `std::unique_lock`.",
                  "Upon wakeup (timeout), gather GoodForDay order IDs under a short `std::scoped_lock`, then call `CancelOrders(orderIds)` to batch-cancel inside a single critical section.",
                  "In the destructor, set the shutdown flag (`std::atomic<bool>`), notify the condition variable, and `join()` the thread.",
                  "Keep time calculations outside the locked sections to avoid blocking other API calls."
                ]
              }
            ],
            "required_skills": [
              "C++ threading with std::thread",
              "Mutex/lock management (std::mutex, std::unique_lock, std::scoped_lock)",
              "Condition variables for timed waits",
              "Time calculations with <chrono> and <ctime>",
              "Atomic flags for shutdown coordination"
            ],
            "learning_materials": [
              "Why batch cancellations: acquiring the mutex once to cancel many orders reduces contention and cache thrashing.",
              "Timed waits with condition variables: efficiently sleep until a deadline but allow immediate wake-up on shutdown.",
              "Local time scheduling: converting between system_clock and calendar time to target a wall-clock event.",
              "Separation of concerns: background maintenance is isolated; public APIs remain simple and responsive."
            ],
            "c++_functions": [
              "std::thread (constructor, join)",
              "std::mutex, std::unique_lock, std::scoped_lock",
              "std::condition_variable::wait_for",
              "std::atomic<bool>::store / ::load",
              "std::chrono::system_clock, std::chrono::hours, std::chrono::milliseconds",
              "std::localtime_s, std::mktime"
            ],
            "code_snippets": [
              {
                "filename": "Orderbook.cpp (constructor & destructor)",
                "code": "Orderbook::Orderbook() : ordersPruneThread_{ [this] { PruneGoodForDayOrders(); } } { }\n\nOrderbook::~Orderbook()\n{\n    shutdown_.store(true, std::memory_order_release);\n    shutdownConditionVariable_.notify_one();\n    ordersPruneThread_.join();\n}\n"
              },
              {
                "filename": "Orderbook.cpp (PruneGoodForDayOrders)",
                "code": "void Orderbook::PruneGoodForDayOrders()\n{    \n    using namespace std::chrono;\n    const auto end = hours(16);\n\n\twhile (true)\n\t{\n\t\tconst auto now = system_clock::now();\n\t\tconst auto now_c = system_clock::to_time_t(now);\n\t\tstd::tm now_parts;\n\t\tlocaltime_s(&now_parts, &now_c);\n\n\t\tif (now_parts.tm_hour >= end.count())\n\t\t\tnow_parts.tm_mday += 1;\n\n\t\tnow_parts.tm_hour = end.count();\n\t\tnow_parts.tm_min = 0;\n\t\tnow_parts.tm_sec = 0;\n\n\t\tauto next = system_clock::from_time_t(mktime(&now_parts));\n\t\tauto till = next - now + milliseconds(100);\n\n\t\t{\n\t\t\tstd::unique_lock ordersLock{ ordersMutex_ };\n\n\t\t\tif (shutdown_.load(std::memory_order_acquire) ||\n\t\t\t\tshutdownConditionVariable_.wait_for(ordersLock, till) == std::cv_status::no_timeout)\n\t\t\t\treturn;\n\t\t}\n\n\t\tOrderIds orderIds;\n\n\t\t{\n\t\t\tstd::scoped_lock ordersLock{ ordersMutex_ };\n\n\t\t\tfor (const auto& [_, entry] : orders_)\n\t\t\t{\n\t\t\t\tconst auto& [order, _] = entry;\n\n\t\t\t\tif (order->GetOrderType() != OrderType::GoodForDay)\n\t\t\t\t\tcontinue;\n\n\t\t\t\torderIds.push_back(order->GetOrderId());\n\t\t\t}\n\t\t}\n\n\t\tCancelOrders(orderIds);\n\t}\n}\n"
              }
            ]
        },
        {
            "name": "11. Level Metadata Bookkeeping",
            "overview": "Maintain fast, per-price aggregates (total quantity and order count) via event-style hooks so feasibility checks (e.g., FOK) and housekeeping remain O(levels) instead of O(orders). Updates happen only through centralized helpers to keep invariants consistent.",
            "what_and_how": [
              {
                "file": "include/Orderbook.h",
                "spec": "Declare the LevelData structure (per-price aggregates) and the private event/update APIs that keep it in sync with order lifecycle events.",
                "how_to_implement": [
                  "Embed a small `LevelData` struct holding `quantity_` and `count_` along with an `Action` enum { Add, Remove, Match }.",
                  "Store the metadata in `std::unordered_map<Price, LevelData> data_` for O(1)-ish access keyed by price.",
                  "Declare private helpers: `OnOrderAdded`, `OnOrderCancelled`, `OnOrderMatched`, and `UpdateLevelData`."
                ]
              },
              {
                "file": "src/Orderbook.cpp",
                "spec": "Implement the event hooks so every add/cancel/fill flows through `UpdateLevelData`, which adjusts `count_` and `quantity_` consistently and erases empty levels.",
                "how_to_implement": [
                  "On add: increment `count_` and add the order's initial quantity.",
                  "On cancel: decrement `count_` and subtract the order's remaining quantity (what still sat on the book).",
                  "On match: subtract the matched quantity; if the order was fully filled, also decrement `count_`.",
                  "In `UpdateLevelData`, centralize the arithmetic and erase the price from `data_` when `count_` reaches zero."
                ]
              }
            ],
            "required_skills": [
              "Associative containers (`std::unordered_map`)",
              "Designing and enforcing invariants across event hooks",
              "Encapsulation of state transitions in helper functions",
              "Understanding of matching side-effects on level aggregates"
            ],
            "learning_materials": [
              "Aggregating per-price metadata makes FOK checks and UI summaries efficient and decoupled from per-order structures.",
              "Event-driven updates localize complexity: all mutations to aggregates happen in one place (`UpdateLevelData`).",
              "Consistent rules: add uses initial qty; cancel uses remaining qty; match uses the actual filled qty."
            ],
            "c++_functions": [
              "std::unordered_map (insert, operator[], erase)",
              "Enum classes for action tags",
              "Private helper methods for lifecycle events",
              "Conditional arithmetic and invariant checks"
            ],
            "code_snippets": [
              {
                "filename": "Orderbook.cpp (OnOrderCancelled / OnOrderAdded / OnOrderMatched / UpdateLevelData)",
                "code": "void Orderbook::OnOrderCancelled(OrderPointer order)\n{\n    UpdateLevelData(order->GetPrice(), order->GetRemainingQuantity(), LevelData::Action::Remove);\n}\n\nvoid Orderbook::OnOrderAdded(OrderPointer order)\n{\n    UpdateLevelData(order->GetPrice(), order->GetInitialQuantity(), LevelData::Action::Add);\n}\n\nvoid Orderbook::OnOrderMatched(Price price, Quantity quantity, bool isFullyFilled)\n{\n    UpdateLevelData(price, quantity, isFullyFilled ? LevelData::Action::Remove : LevelData::Action::Match);\n}\n\nvoid Orderbook::UpdateLevelData(Price price, Quantity quantity, LevelData::Action action)\n{\n    auto& data = data_[price];\n\n    data.count_ += action == LevelData::Action::Remove ? -1 : action == LevelData::Action::Add ? 1 : 0;\n    if (action == LevelData::Action::Remove || action == LevelData::Action::Match)\n    {\n        data.quantity_ -= quantity;\n    }\n    else\n    {\n        data.quantity_ += quantity;\n    }\n\n    if (data.count_ == 0)\n        data_.erase(price);\n}\n"
              }
            ]
        }
    ]
  }
  